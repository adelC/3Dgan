# -*- coding: utf-8 -*-
"""AngleGAN_bfloat16.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dERoUZ4hQI_vFj9FDxrdYZpVrwpqvUpx
"""

from __future__ import print_function
import os
from collections import defaultdict
try:
    import cPickle as pickle
except ImportError:
    import pickle
    import sys
import h5py 
import time
import numpy as np
import tensorflow as tf

import distutils
if distutils.version.LooseVersion(tf.__version__) < '1.14':
    raise Exception('This notebook is compatible with TensorFlow 1.14 or higher, for TensorFlow 1.13 or lower please use the previous version at https://github.com/tensorflow/tpu/blob/r1.13/tools/colab/fashion_mnist.ipynb')

import math
print (tf.__version__)

#if tpu:
#  BATCH_SIZE = 128  # On TPU in Keras, this is the per-core batch size. The global batch size is 8x this.
#else:
#  BATCH_SIZE = 32  # On Colab/GPU, a higher batch size does not help and sometimes does not fit on the GPU (OOM)

# calculate sum of intensities
def ecal_sum(image, daxis):
    sum = tf.keras.backend.sum(image, axis=daxis)
    return sum

# counts for various bin entries   
def count(image, daxis):
    limits=[0.05, 0.03, 0.02, 0.0125, 0.008, 0.003] # bin boundaries used
    bin1 = tf.keras.backend.sum(tf.where(image > limits[0], tf.ones_like(image), tf.zeros_like(image)), axis=daxis)
    bin2 = tf.keras.backend.sum(tf.where(tf.logical_and(image < limits[0], image > limits[1]), tf.ones_like(image), tf.zeros_like(image)), axis=daxis)
    bin3 = tf.keras.backend.sum(tf.where(tf.logical_and(image < limits[1], image > limits[2]), tf.ones_like(image), tf.zeros_like(image)), axis=daxis)
    bin4 = tf.keras.backend.sum(tf.where(tf.logical_and(image < limits[2], image > limits[3]), tf.ones_like(image), tf.zeros_like(image)), axis=daxis)
    bin5 = tf.keras.backend.sum(tf.where(tf.logical_and(image < limits[3], image > limits[4]), tf.ones_like(image), tf.zeros_like(image)), axis=daxis)
    bin6 = tf.keras.backend.sum(tf.where(tf.logical_and(image < limits[4], image > limits[5]), tf.ones_like(image), tf.zeros_like(image)), axis=daxis)
    bin7 = tf.keras.backend.sum(tf.where(tf.logical_and(image < limits[5], image > 0.0), tf.ones_like(image), tf.zeros_like(image)), axis=daxis)
    bin8 = tf.keras.backend.sum(tf.where(tf.equal(image, 0.0), tf.ones_like(image), tf.zeros_like(image)), axis=daxis)
    bins = tf.expand_dims(tf.keras.backend.concatenate([bin1, bin2, bin3, bin4, bin5, bin6, bin7, bin8], axis=1), axis=-1)
    return bins

# angle calculation 
def ecal_angle(image, daxis):
    image = tf.squeeze(image, axis=daxis)# squeeze along channel axis
    
    # get shapes
    x_shape= tf.keras.backend.int_shape(image)[1]
    y_shape= tf.keras.backend.int_shape(image)[2]
    z_shape= tf.keras.backend.int_shape(image)[3]
    sumtot = tf.keras.backend.sum(image, axis=(1, 2, 3))# sum of events

    # get 1. where event sum is 0 and 0 elsewhere
    amask = tf.where(tf.equal(sumtot, 0.0), tf.ones_like(sumtot) , tf.zeros_like(sumtot))
    masked_events = tf.keras.backend.sum(amask) # counting zero sum events
    
    # ref denotes barycenter as that is our reference point
    x_ref = tf.keras.backend.sum(tf.keras.backend.sum(image, axis=(2, 3)) * (tf.cast(tf.expand_dims(tf.keras.backend.arange(x_shape), 0), dtype='float32') + 0.5) , axis=1)# sum for x position * x index
    y_ref = tf.keras.backend.sum(tf.keras.backend.sum(image, axis=(1, 3)) * (tf.cast(tf.expand_dims(tf.keras.backend.arange(y_shape), 0), dtype='float32') + 0.5), axis=1)
    z_ref = tf.keras.backend.sum(tf.keras.backend.sum(image, axis=(1, 2)) * (tf.cast(tf.expand_dims(tf.keras.backend.arange(z_shape), 0), dtype='float32') + 0.5), axis=1)
    x_ref = tf.where(tf.equal(sumtot, 0.0), tf.ones_like(x_ref) , x_ref/sumtot)# return max position if sumtot=0 and divide by sumtot otherwise
    y_ref = tf.where(tf.equal(sumtot, 0.0), tf.ones_like(y_ref) , y_ref/sumtot)
    z_ref = tf.where(tf.equal(sumtot, 0.0), tf.ones_like(z_ref), z_ref/sumtot)
    #reshape    
    x_ref = tf.expand_dims(x_ref, 1)
    y_ref = tf.expand_dims(y_ref, 1)
    z_ref = tf.expand_dims(z_ref, 1)

    sumz = tf.keras.backend.sum(image, axis =(1, 2)) # sum for x,y planes going along z

    # Get 0 where sum along z is 0 and 1 elsewhere
    zmask = tf.where(tf.equal(sumz, 0.0), tf.zeros_like(sumz) , tf.ones_like(sumz))
        
    x = tf.expand_dims(tf.keras.backend.arange(x_shape), 0) # x indexes
    x = tf.cast(tf.expand_dims(x, 2), dtype='float32') + 0.5
    y = tf.expand_dims(tf.keras.backend.arange(y_shape), 0)# y indexes
    y = tf.cast(tf.expand_dims(y, 2), dtype='float32') + 0.5
  
    #barycenter for each z position
    x_mid = tf.keras.backend.sum(tf.keras.backend.sum(image, axis=2) * x, axis=1)
    y_mid = tf.keras.backend.sum(tf.keras.backend.sum(image, axis=1) * y, axis=1)
    x_mid = tf.where(tf.equal(sumz, 0.0), tf.zeros_like(sumz), x_mid/sumz) # if sum != 0 then divide by sum
    y_mid = tf.where(tf.equal(sumz, 0.0), tf.zeros_like(sumz), y_mid/sumz) # if sum != 0 then divide by sum

    #Angle Calculations
    z = (tf.cast(tf.keras.backend.arange(z_shape), dtype='float32') + 0.5)  * tf.ones_like(z_ref) # Make an array of z indexes for all events
    zproj = tf.sqrt(tf.maximum((x_mid-x_ref)**2.0 + (z - z_ref)**2.0, tf.keras.backend.epsilon()))# projection from z axis with stability check
    m = tf.where(tf.equal(zproj, 0.0), tf.zeros_like(zproj), (y_mid-y_ref)/zproj)# to avoid divide by zero for zproj =0
    m = tf.where(tf.less(z, z_ref),  -1 * m, m)# sign inversion
    ang = (math.pi/2.0) - tf.atan(m)# angle correction
    zmask = tf.where(tf.equal(zproj, 0.0), tf.zeros_like(zproj) , zmask)
    ang = ang * zmask # place zero where zsum is zero
    
    ang = ang * z  # weighted by position
    sumz_tot = z * zmask # removing indexes with 0 energies or angles

    #zunmasked = K.sum(zmask, axis=1) # used for simple mean 
    #ang = K.sum(ang, axis=1)/zunmasked # Mean does not include positions where zsum=0

    ang = tf.keras.backend.sum(ang, axis=1)/tf.keras.backend.sum(sumz_tot, axis=1) # sum ( measured * weights)/sum(weights)
    ang = tf.where(tf.equal(amask, 0.), ang, 100. * tf.ones_like(ang)) # Place 100 for measured angle where no energy is deposited in events
    
    ang = tf.expand_dims(ang, 1)
    return ang

def discriminator(power=1.0, dformat='channels_last'):
    #tf.set_image_data_format(dformat)
    if dformat =='channels_last':
        dshape=(51, 51, 25,1) # sample shape
        daxis=4 # channel axis 
        baxis=-1 # axis for BatchNormalization
        daxis2=(1, 2, 3) # axis for sum
    else:
        dshape=(1, 51, 51, 25) 
        daxis=1 
        baxis=1 
        daxis2=(2, 3, 4)
    image=tf.keras.layers.Input(shape=dshape)

    x = tf.keras.layers.Conv3D(16, (5, 6, 6), padding='same')(image)
    x = tf.keras.layers.LeakyReLU()(x)
    x = tf.keras.layers.Dropout(0.2)(x)

    x = tf.keras.layers.ZeroPadding3D((0, 0, 1))(x)
    x = tf.keras.layers.Conv3D(8, (5, 6, 6), padding='valid')(x)
    x = tf.keras.layers.LeakyReLU()(x)
    x = tf.keras.layers.BatchNormalization(axis=baxis, epsilon=1e-6)(x)
    x = tf.keras.layers.Dropout(0.2)(x)

    x = tf.keras.layers.ZeroPadding3D((0, 0, 1))(x)
    x = tf.keras.layers.Conv3D(8, (5, 6, 6), padding='valid')(x)
    x = tf.keras.layers.LeakyReLU()(x)
    x = tf.keras.layers.BatchNormalization(axis=baxis, epsilon=1e-6)(x)
    x = tf.keras.layers.Dropout(0.2)(x)

    x = tf.keras.layers.Conv3D(8, (5, 6, 6), padding='valid')(x)
    x = tf.keras.layers.LeakyReLU()(x)
    x = tf.keras.layers.BatchNormalization(axis=baxis, epsilon=1e-6)(x)
    x = tf.keras.layers.Dropout(0.2)(x)

    x = tf.keras.layers.AveragePooling3D((2, 2, 2))(x)
    h = tf.keras.layers.Flatten()(x)

    dnn = tf.keras.models.Model(image, h)
    dnn.summary()

    dnn_out = dnn(image)
    fake = tf.keras.layers.Dense(1, activation='sigmoid', name='generation')(dnn_out)
    aux = tf.keras.layers.Dense(1, activation='linear', name='auxiliary')(dnn_out)
    inv_image = tf.keras.layers.Lambda(tf.keras.backend.pow, arguments={'a':1./power})(image) #get back original image
    ang = tf.keras.layers.Lambda(ecal_angle, arguments={'daxis':daxis})(inv_image) # angle calculation
    ecal = tf.keras.layers.Lambda(ecal_sum, arguments={'daxis':daxis2})(inv_image) # sum of energies
    add_loss = tf.keras.layers.Lambda(count, arguments={'daxis':daxis2})(inv_image) # loss for bin counts
    d_model=tf.keras.models.Model(inputs=[image], outputs=[fake, aux, ang, ecal, add_loss])
    d_model.summary()
    return d_model

def generator(latent_size=256, return_intermediate=False, dformat='channels_last'):
    if dformat =='channels_last':
        dim = (9,9,8,8) # shape for dense layer
        baxis=-1 # axis for BatchNormalization
    else:
        dim = (8, 9, 9,8)
        baxis=1
    #tf.set_image_data_format(dformat)
    loc = tf.keras.models.Sequential([
        tf.keras.layers.Dense(5184, input_shape=(latent_size,)),
        tf.keras.layers.Reshape(dim),
        tf.keras.layers.UpSampling3D(size=(6, 6, 6)),
        
        tf.keras.layers.Conv3D(8, (6, 6, 8), padding='valid', kernel_initializer='he_uniform'),
        tf.keras.layers.Activation('relu'),
        tf.keras.layers.BatchNormalization(axis=baxis, epsilon=1e-6),
        
        tf.keras.layers.ZeroPadding3D((2, 2, 1)),
        tf.keras.layers.Conv3D(6, (4, 4, 6), padding='valid', kernel_initializer='he_uniform'),
        tf.keras.layers.Activation('relu'),
        tf.keras.layers.BatchNormalization(axis=baxis, epsilon=1e-6),
        ####################################### added layers 
        
        tf.keras.layers.ZeroPadding3D((2, 2, 1)),
        tf.keras.layers.Conv3D(6, (4, 4, 6), padding='valid', kernel_initializer='he_uniform'),
        tf.keras.layers.Activation('relu'),
        tf.keras.layers.BatchNormalization(axis=baxis, epsilon=1e-6),

        tf.keras.layers.ZeroPadding3D((2, 2, 1)),
        tf.keras.layers.Conv3D(6, (4, 4, 6), padding='valid', kernel_initializer='he_uniform'),
        tf.keras.layers.Activation('relu'),
        tf.keras.layers.BatchNormalization(axis=baxis, epsilon=1e-6),

        tf.keras.layers.ZeroPadding3D((1, 1, 0)),
        tf.keras.layers.Conv3D(6, (3, 3, 5), padding='valid', kernel_initializer='he_uniform'),
        tf.keras.layers.Activation('relu'),
        tf.keras.layers.BatchNormalization(axis=baxis, epsilon=1e-6),
        
        #####################################  
        
        tf.keras.layers.ZeroPadding3D((1, 1, 0)),
        tf.keras.layers.Conv3D(6, (3, 3, 3), padding='valid', kernel_initializer='he_uniform'),
        tf.keras.layers.Activation('relu'),
        
        tf.keras.layers.Conv3D(1, (2, 2, 2),  padding='valid', kernel_initializer='glorot_normal'),
        tf.keras.layers.Activation('relu')
    ])
    latent = tf.keras.layers.Input(shape=(latent_size, ))   
    fake_image = loc(latent)
    loc.summary()
    return loc

